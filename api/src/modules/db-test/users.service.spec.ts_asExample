import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersService } from './user.service';
import { UserEntity } from './user.entity';
import DbModule from './db-test.module';

const testUser = {
  email: 'test@test.com',
  firstName: 'earrieta',
  lastName: 'dev',
};

const wait = time => new Promise(resolve => setTimeout(() => resolve(time), time));

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: [
        DbModule({
          name: (new Date().getTime() * Math.random()).toString(16), // <-- This is to have a "unique" name for the connection
        }),
        TypeOrmModule.forFeature([
          UserEntity,
        ]),
      ],
      providers: [
        UsersService,
      ],
    }).compile();

    service = module.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should return a new entity', () => {
    const user = service.create(testUser);

    expect(user).toEqual(testUser);
    expect(user instanceof UserEntity).toBe(true);
  });

  it('should save the user and add the createdAt and savedAt fields', async () => {
    const user = service.create(testUser);
    await service.save(user);

    expect(user.createdAt).toBeTruthy();
    expect(user.updatedAt).toBeTruthy();
  });

  it('should update the updatedAt field after an update (with the save method of the service)', async () => {
    const user = service.create(testUser);
    expect(user.updatedAt).not.toBeTruthy();

    await service.save(user);
    expect(user.updatedAt).toBeTruthy();
    expect(user.createdAt.getTime()).toBe(user.updatedAt.getTime());

    const actualUpdate = user.updatedAt;
    user.email = 'test2@test2.com';
    expect(user.updatedAt.getTime()).toBe(actualUpdate.getTime());

    await service.save(user);
    await wait(20); // <-- this is just to simulate an update after "some time"
    expect(user.updatedAt.getTime()).toBeGreaterThan(actualUpdate.getTime());
  });
});